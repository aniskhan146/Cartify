-- AYEXPRESS E-COMMERCE PLATFORM SCHEMA
-- This script sets up all necessary tables, roles, and security policies for the application.
-- Run this entire script in your Supabase SQL Editor.

-- Drop existing tables if they exist to start fresh (optional, use with caution)
-- DROP TABLE IF EXISTS public.newsletter_subscriptions CASCADE;
-- DROP TABLE IF EXISTS public.wishlists CASCADE;
-- DROP TABLE IF EXISTS public.orders CASCADE;
-- DROP TABLE IF EXISTS public.profiles CASCADE;
-- DROP TABLE IF EXISTS public.storefront_settings CASCADE;
-- DROP TABLE IF EXISTS public.products CASCADE;
-- DROP TABLE IF EXISTS public.variant_options CASCADE;
-- DROP TABLE IF EXISTS public.categories CASCADE;
-- DROP FUNCTION IF EXISTS public.update_category_product_count() CASCADE;
-- DROP FUNCTION IF EXISTS public.is_admin() CASCADE;

-- 1. CATEGORIES TABLE
-- Stores product categories.
CREATE TABLE IF NOT EXISTS public.categories (
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    name text NOT NULL UNIQUE,
    icon_url text,
    product_count integer NOT NULL DEFAULT 0,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT categories_pkey PRIMARY KEY (id)
);
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.categories IS 'Stores product categories like Electronics, Fashion, etc.';

-- 2. VARIANT OPTIONS TABLE
-- Stores reusable variant types (e.g., Color, Size) and their possible values.
CREATE TABLE IF NOT EXISTS public.variant_options (
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    name text NOT NULL UNIQUE,
    values jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT variant_options_pkey PRIMARY KEY (id)
);
ALTER TABLE public.variant_options ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.variant_options IS 'Defines variant types (e.g., "Color") and their possible values (e.g., ["Red", "Blue"]).';

-- 3. PRODUCTS TABLE
-- Stores all product information.
CREATE TABLE IF NOT EXISTS public.products (
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    name text NOT NULL,
    category text NOT NULL,
    description text,
    image_urls text[],
    rating real DEFAULT 0,
    reviews integer DEFAULT 0,
    variants jsonb,
    delivery_timescale text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT products_pkey PRIMARY KEY (id)
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.products IS 'Stores detailed information about each product.';

-- 4. STOREFRONT SETTINGS TABLE
-- A single-row table to hold general storefront settings.
CREATE TABLE IF NOT EXISTS public.storefront_settings (
    id integer NOT NULL PRIMARY KEY DEFAULT 1,
    hero_images text[],
    checkout_config jsonb,
    CONSTRAINT storefront_settings_singleton CHECK (id = 1)
);
ALTER TABLE public.storefront_settings ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.storefront_settings IS 'Singleton table for global storefront configurations like hero images.';

-- 5. PROFILES TABLE
-- Stores user profile data and roles, linked to the auth.users table.
CREATE TABLE IF NOT EXISTS public.profiles (
    uid uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    email text NOT NULL UNIQUE,
    display_name text,
    role text NOT NULL DEFAULT 'user',
    is_banned boolean NOT NULL DEFAULT false,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT profiles_pkey PRIMARY KEY (uid)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.profiles IS 'Stores user profiles and application-specific roles.';

-- 6. ORDERS TABLE
-- Stores customer order information.
CREATE TABLE IF NOT EXISTS public.orders (
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    customer_name text,
    date timestamp with time zone NOT NULL DEFAULT now(),
    total numeric NOT NULL,
    status text NOT NULL DEFAULT 'Pending',
    items jsonb,
    CONSTRAINT orders_pkey PRIMARY KEY (id)
);
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.orders IS 'Contains all customer order data.';

-- 7. WISHLISTS TABLE
-- Stores user wishlists.
CREATE TABLE IF NOT EXISTS public.wishlists (
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    product_id uuid NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT wishlists_pkey PRIMARY KEY (user_id, product_id)
);
ALTER TABLE public.wishlists ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.wishlists IS 'Associates users with products they have wishlisted.';

-- 8. NEWSLETTER SUBSCRIPTIONS TABLE
-- Stores emails for the newsletter.
CREATE TABLE IF NOT EXISTS public.newsletter_subscriptions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email text NOT NULL UNIQUE,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);
ALTER TABLE public.newsletter_subscriptions ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE public.newsletter_subscriptions IS 'Collects email addresses for newsletter marketing.';

-- 9. TRIGGERS & FUNCTIONS
-- Function to update product counts in the categories table.
CREATE OR REPLACE FUNCTION public.update_category_product_count()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE public.categories
        SET product_count = product_count + 1
        WHERE name = NEW.category;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE public.categories
        SET product_count = product_count - 1
        WHERE name = OLD.category;
    ELSIF (TG_OP = 'UPDATE' AND NEW.category <> OLD.category) THEN
        -- Product moved to a new category
        UPDATE public.categories
        SET product_count = product_count - 1
        WHERE name = OLD.category;
        UPDATE public.categories
        SET product_count = product_count + 1
        WHERE name = NEW.category;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to execute the function on product changes.
DROP TRIGGER IF EXISTS on_product_change_update_category_count ON public.products;
CREATE TRIGGER on_product_change_update_category_count
AFTER INSERT OR DELETE OR UPDATE OF category ON public.products
FOR EACH ROW EXECUTE FUNCTION public.update_category_product_count();

-- 10. ROW LEVEL SECURITY (RLS) POLICIES
-- Drop existing policies to avoid conflicts
DROP POLICY IF EXISTS "Public can read all categories" ON public.categories;
DROP POLICY IF EXISTS "Admins can manage categories" ON public.categories;
DROP POLICY IF EXISTS "Allow insert for seeding if table is empty" ON public.categories;
DROP POLICY IF EXISTS "Public can read all variant options" ON public.variant_options;
DROP POLICY IF EXISTS "Admins can manage variant options" ON public.variant_options;
DROP POLICY IF EXISTS "Allow insert for seeding if table is empty" ON public.variant_options;
DROP POLICY IF EXISTS "Public can read all products" ON public.products;
DROP POLICY IF EXISTS "Admins can manage products" ON public.products;
DROP POLICY IF EXISTS "Allow insert for seeding if table is empty" ON public.products;
DROP POLICY IF EXISTS "Public can read storefront settings" ON public.storefront_settings;
DROP POLICY IF EXISTS "Admins can manage storefront settings" ON public.storefront_settings;
DROP POLICY IF EXISTS "Allow insert for seeding if table is empty" ON public.storefront_settings;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can create their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Admins can manage all profiles" ON public.profiles;
DROP POLICY IF EXISTS "Users can manage their own orders" ON public.orders;
DROP POLICY IF EXISTS "Admins can manage all orders" ON public.orders;
DROP POLICY IF EXISTS "Users can manage their own wishlist" ON public.wishlists;
DROP POLICY IF EXISTS "Public can subscribe to newsletter" ON public.newsletter_subscriptions;
DROP POLICY IF EXISTS "Admins can read subscriptions" ON public.newsletter_subscriptions;

-- HELPER FUNCTION to check admin role
CREATE OR REPLACE FUNCTION is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.profiles
    WHERE uid = auth.uid() AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Categories Policies
CREATE POLICY "Public can read all categories" ON public.categories FOR SELECT USING (true);
CREATE POLICY "Admins can manage categories" ON public.categories FOR ALL USING (is_admin());
CREATE POLICY "Allow insert for seeding if table is empty" ON public.categories FOR INSERT WITH CHECK ((SELECT count(*) FROM public.categories) = 0);

-- Variant Options Policies
CREATE POLICY "Public can read all variant options" ON public.variant_options FOR SELECT USING (true);
CREATE POLICY "Admins can manage variant options" ON public.variant_options FOR ALL USING (is_admin());
CREATE POLICY "Allow insert for seeding if table is empty" ON public.variant_options FOR INSERT WITH CHECK ((SELECT count(*) FROM public.variant_options) = 0);

-- Products Policies
CREATE POLICY "Public can read all products" ON public.products FOR SELECT USING (true);
CREATE POLICY "Admins can manage products" ON public.products FOR ALL USING (is_admin());
CREATE POLICY "Allow insert for seeding if table is empty" ON public.products FOR INSERT WITH CHECK ((SELECT count(*) FROM public.products) = 0);

-- Storefront Settings Policies
CREATE POLICY "Public can read storefront settings" ON public.storefront_settings FOR SELECT USING (true);
CREATE POLICY "Admins can manage storefront settings" ON public.storefront_settings FOR ALL USING (is_admin());
CREATE POLICY "Allow insert for seeding if table is empty" ON public.storefront_settings FOR INSERT WITH CHECK ((SELECT count(*) FROM public.storefront_settings) = 0);

-- Profiles Policies (FIX: Added separate insert policy)
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = uid);
CREATE POLICY "Users can create their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = uid);
CREATE POLICY "Admins can manage all profiles" ON public.profiles FOR ALL USING (is_admin());

-- Orders Policies
CREATE POLICY "Users can manage their own orders" ON public.orders FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Admins can manage all orders" ON public.orders FOR ALL USING (is_admin());

-- Wishlists Policies
CREATE POLICY "Users can manage their own wishlist" ON public.wishlists FOR ALL USING (auth.uid() = user_id);

-- Newsletter Subscriptions Policies
CREATE POLICY "Public can subscribe to newsletter" ON public.newsletter_subscriptions FOR INSERT WITH CHECK (true);
CREATE POLICY "Admins can read subscriptions" ON public.newsletter_subscriptions FOR SELECT USING (is_admin());

-- END OF SCHEMA SCRIPT
-- Your database is now ready for the AYExpress application.